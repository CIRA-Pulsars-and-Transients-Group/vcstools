/*
 * check_corr.c
 *
 *  Created on: May 4, 2012
 *      Author: sord
 */
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <complex.h>
#include <sys/stat.h>
#include <time.h>
#include "antenna_mapping.h"
#include "antenna.h"
#include "freqseries.h"
#include "plot.h"
#include "fitsio.h"
int npol;
int nstation;
int nfrequency;

void printerror( int status)
{
  /*****************************************************/
  /* Print out cfitsio error messages and exit program */
  /*****************************************************/

  char status_str[FLEN_STATUS], errmsg[FLEN_ERRMSG];

  if (status)
    fprintf(stderr, "\n*** Error occurred during program execution ***\n");

  fits_get_errstatus(status, status_str);   /* get the error description */
  fprintf(stderr, "\nstatus = %d: %s\n", status, status_str);

  /* get first message; null if stack is empty */
  if ( fits_read_errmsg(errmsg) )
  {
    fprintf(stderr, "\nError message stack:\n");
    fprintf(stderr, " %s\n", errmsg);

    while ( fits_read_errmsg(errmsg) )  /* get remaining messages */
      fprintf(stderr, " %s\n", errmsg);
  }

  exit( status );       /* terminate the program, returning error status */
}

void usage() {
	fprintf(stdout,
			"Simple Utility to display a bandpass from a raw (MWAC) correlator output cube");
	fprintf(stdout,
			"\ncheck_corr -a <antenna 1> -b <antenna 2> -c <antenna 3> -v <file>\n");
	fprintf(stdout,
			"\nNote: the antenna labels are PFB input antenna numbers - this utility attempts to extract the correct baseline from the MWAC cube");
	fprintf(stdout, 
			"\nClosure: If a third (-c) antenna is given the closure phase spectrum will be returned"); 
	fprintf(stdout,
			"\nAlso: this uses the CURRENT installed HarvardX - if you use it on cubes generated by other versions of the Xengine you will get incorrect results\n");
	fprintf(stdout, "Other options (-s <nstations> [32])\n");

}
int main(int argc, char **argv) {

	int antenna1 = 0;
	int antenna2 = 0;
	int antenna3 = 0;
	int closure = 0;
	int pol1 = 0;
	int pol2 = 0;
	int autos=1;

	char *cvalue = NULL;
	int index;
	int c;
	int raw = 0;
	extern int npol;
	extern int nstation;
	extern int nfrequency;





	npol = 2;
	nstation = 128;
	nfrequency = 128;

	opterr = 0;

	while ((c = getopt(argc, argv, "a:b:cn:rv:s:")) != -1)
		switch (c) {
		case 'a':
			antenna1 = atoi(optarg);
			break;
		case 'b':
			antenna2 = atoi(optarg);
			break;
		case 'c':
			antenna3 = atoi(optarg);
			closure=1;
			break;
		case 'r':
			raw = 1;
			break;
		case 'n':
			nfrequency = atoi(optarg);
			break;
		case 's':
			nstation = atoi(optarg);
			break;
		case 'v':
			cvalue = optarg;
			break;
		case '?':
			if (optopt == 'c')
				fprintf(stderr, "Option -%c requires an argument.\n", optopt);
			else if (isprint(optopt))
				fprintf(stderr, "Unknown option `-%c'.\n", optopt);
			else
				fprintf(stderr, "Unknown option character `\\x%x'.\n", optopt);
			return 1;
		default:
			exit(EXIT_FAILURE);
		}

	printf("antenna 1 = %d, antenna 2 = %d, input file = %s\n", antenna1,
			antenna2, cvalue);

	for (index = optind; index < argc; index++)
		printf("Non-option argument %s\n", argv[index]);

	size_t nvis = (nstation + 1)*(nstation/2)*npol*npol;

	size_t matLength = nfrequency*nvis; // cuda_matrix length (autos on the diagonal)

	size_t matrix_size = matLength * sizeof(float complex);
	size_t full_matLength = nfrequency * nstation * nstation * npol * npol;
	size_t full_size = full_matLength * sizeof(float complex);
	size_t baseLength = nfrequency;

	printf(
			"current assumptions: Nchannels: %d NStations: %d NPol: %d: Matrix Size(bytes) %d and Length (Complex samples) %d: \n",
			nfrequency, nstation, npol, matrix_size, matLength);

	if (cvalue != NULL) {

		fitsfile *fptr;
		int rtn;
		float complex *cuda_matrix_h = NULL;
		float complex *full_matrix_h = NULL;
		float complex *baseline_h = NULL;
		float complex *baseline_t = NULL;
		cuda_matrix_h = (float complex *) malloc(matrix_size);
		full_matrix_h = (float complex *) malloc(full_size);
		baseline_h = (float complex *) malloc(
				baseLength * sizeof(float complex));
		baseline_t = (float complex *) malloc(
						baseLength * sizeof(float complex));

		struct stat buffer;
		stat(cvalue,&buffer);

		int status=0;
		
		if (!fits_open_file(&fptr, cvalue, READONLY, &status))
		{

	
			long fpixel = 1;
			float nullval = 0;
			int anynull = 0x0;
			int nfound = 0;
			long naxes[2];
			long npixels = 0;

			if (fits_read_keys_lng(fptr,"NAXIS",1,2,naxes,&nfound,&status)) {
				printerror(status);
			}

			status = 0;
			npixels = naxes[0] * naxes[1];
			if (fits_read_img(fptr,TFLOAT,fpixel,npixels,&nullval,(float *)cuda_matrix_h,&anynull,&status)) {
				printerror(status);
			}
		
			char device[256];
			fant_t baseline;
			int ant_num=0;
			int pairs[4][2];

			init_Fantenna(0, 1, nfrequency, 4, 2, &baseline);

			baseline.info.cmac = 1;

			fprintf(stdout,
					"Full matrix read in for a single time step  -- will reorder to triangular\n");
			// wacky packed tile order to packed triangular
			// xgpuReorderMatrix((Complex *) cuda_matrix_h);
			// convert from packed triangular to full matrix
			 extractMatrix(full_matrix_h, cuda_matrix_h);
			// get the mapping
			fill_mapping_matrix();
			// get a baseline
			int the_pol = 0;
		
			if (closure) {
				/* need to calculate the closure spectrum which requires 4 baselines:
				 *
				 * 			
				 * 				1) antenna1 * antenna1
				 * 				2) antenna1 * antenna2
				 * 				3) antenna2 * antenna3
				 * 				4) antenna3 * antenna1
				 * 				*/

				pairs[0][0] = antenna1;
				pairs[0][1] = antenna1;

				pairs[1][0] = antenna1;
				pairs[1][1] = antenna2;

				pairs[2][0] = antenna2;
				pairs[2][1] = antenna3;

				pairs[3][0] = antenna3;
				pairs[3][1] = antenna1;

			}

			for (pol1 = 0;pol1 < npol;pol1++) {

				for (pol2 =0; pol2 < npol; pol2++) {

					int index1 = antenna1 * npol + pol1;
					int index2 = antenna2 * npol + pol2;
					int corr_stn1 = 0, corr_pol1 = 0;
					int corr_stn2 = 0, corr_pol2 = 0;
					
					fprintf(stdout, "requesting ant1 %d ant 2 %d pol1 %d pol2 %d",
							antenna1, antenna2, pol1, pol2);
					   
					map_t the_mapping = corr_mapping[index1][index2];
					
					fprintf(stdout,
							"input ant/pol combination decodes to stn1 %d stn2 %d pol1 %d pol2 %d\n",
					   the_mapping.stn1, the_mapping.stn2, the_mapping.pol1,
					   the_mapping.pol2);
					  

					if (!raw) {

						/* I dont *think* this is required anymore

						   if (the_mapping.stn2 > the_mapping.stn1) {
						   corr_stn2 = the_mapping.stn1;
						   corr_stn1 = the_mapping.stn2;
						   corr_pol2 = the_mapping.pol1;
						   corr_pol1 = the_mapping.pol2;
						   }

						   else {
						   corr_stn1 = the_mapping.stn1;
						   corr_stn2 = the_mapping.stn2;
						   corr_pol1 = the_mapping.pol1;
						   corr_pol2 = the_mapping.pol2;
						   }

*/

						/* replace with just */

						corr_stn1 = the_mapping.stn1;
						corr_stn2 = the_mapping.stn2;
						corr_pol1 = the_mapping.pol1;
						corr_pol2 = the_mapping.pol2;

					}
					else {
						if (antenna2>antenna1) {
							corr_stn1 = antenna2;
							corr_stn2 = antenna1;
							corr_pol1 = pol2;
							corr_pol2 = pol1;
						}
						else {
							corr_stn1 = antenna1;
							corr_stn2 = antenna2;
							corr_pol1 = pol1;
							corr_pol2 = pol2;

						}


					}

					get_baseline_lu(corr_stn1, corr_stn2, corr_pol1,
							corr_pol2, full_matrix_h, baseline_h);


					/* fill the antenna struct */

					int freq =0;


					for (freq=0;freq<nfrequency;freq++){
						/*
						   if (antenna1 == 11) {

						   fprintf(stdout,"%d %f %f\n",freq,crealf(baseline_h[freq]),cimag(baseline_h[freq]));
						   }
						   */
						antenna_set_Fchannel(freq, the_pol, &baseline, crealf(baseline_h[freq]), cimagf(baseline_h[freq]));
					}
					the_pol++;
				}
			}
			char title[32];
			sprintf(device,"ant-%d-%d.ps/cps",antenna1,antenna2);
			sprintf(title,"%s",ctime(&buffer.st_mtime));
			PGplot_correlation (&baseline, 1,device,title);
			fits_close_file(fptr,&status);
		}
		else {
			fprintf(stderr, "cannot open %s as FITSFILE\n");
			usage();
			exit(EXIT_FAILURE);
		}

		
	} else {
		fprintf(stderr, "No file given on command line (-v)\n");
		usage();
		exit(EXIT_FAILURE);
	}
	exit(EXIT_SUCCESS);

}

