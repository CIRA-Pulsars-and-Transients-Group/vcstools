#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <inttypes.h>
#include <complex.h>
#include <math.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <time.h>
#include "mwac_utils.h"
#include "ascii_header.h"
#include "mwa_header.h"
#include <omp.h>
#include <mpi.h>
#include <glob.h>
#include <fcntl.h>
#include <assert.h>

// Are GPU available

#ifdef HAVE_CUDA
#include "gpu_utils.h"
#include <cuda_runtime.h>
#else
#define Complex float _Complex
#endif

//
// write out psrfits directly
#include "psrfits.h"
#include "antenna_mapping.h"
#include "beamer_version.h"

#define MAX_COMMAND_LENGTH 1024

void usage() {
    fprintf(stderr,"make_beam -n <nchan> [128] -a <nant> \ntakes input from stdin and dumps to stdout|psrfits\n");
    fprintf(stderr,"-a <number of antennas>\n");
    fprintf(stderr,"-b Begin time [must be supplied]\n");
    fprintf(stderr,"-c <phases file> -- use complex weights\n");
    fprintf(stderr,"-d <data directory root> -- where the recombined data is\n");
    fprintf(stderr,"-D <processing directory root> -- where all the direction dependent files live and where the beams will be put\n");
    fprintf(stderr,"-e End time [must be supplied]\n");
    fprintf(stderr,"-f <psrfits header struct> -- get a psrfits header struct generated by get_delays and output a PSRFITS format beam\n");
    fprintf(stderr,"-j <Jones file> -- antenna Jones matrices\n");
    fprintf(stderr,"-n <number of channels>\n");
    fprintf(stderr,"-N <number> -- 0-offset coarse channel number to process [0]\n");
    fprintf(stderr,"-o obs id\n");
    fprintf(stderr,"-r <sample rate in Hz>\n");
    fprintf(stderr,"-S <bit mask> -- bit number 0 = swap pol, 1 == swap R and I, 2 conjugate sky\n");
    fprintf(stderr,"-V print version number and exit\n");
    fprintf(stderr,"-w <weights file> -- this is now a flag file 1/0 for each input\n");
    fprintf(stderr,"options: -t [1 or 2] sample size : 1 == 8 bit (INT); 2 == 32 bit (FLOAT)\n");

}
void int8_to_uint8(int n, int shift, char * to_convert) {
    int j;
    int scratch;
    int8_t with_sign;

    for (j = 0; j < n; j++) {
        with_sign = (int8_t) *to_convert;
        scratch = with_sign + shift;
        *to_convert = (uint8_t) scratch;
        to_convert++;
    }
}
void float2int8_trunc(float *f, int n, float min, float max, int8_t *i) /*includefile*/
{
    int j;
    for (j = 0; j < n; j++) {
        f[j] = (f[j] > max) ? (max) : f[j];
        f[j] = (f[j] < min) ? (min) : f[j];
        i[j] = (int8_t) rint(f[j]);

    }
}
void to_offset_binary(int8_t *i, int n){
    int j;
    for (j = 0; j < n; j++) {
        i[j] = i[j] ^ 0x80;
    }
}
complex float get_std_dev_complex(complex float *input, int nsamples) {
    // assume zero mean
    float rtotal = 0;
    float itotal = 0;
    float isigma = 0;
    float rsigma = 0;
    int i;

    for (i=0;i<nsamples;i++){
         rtotal = rtotal+(crealf(input[i])*crealf(input[i]));
         itotal = itotal+(cimagf(input[i])*cimagf(input[i]));

     }
    rsigma = sqrtf((1.0/(nsamples-1))*rtotal);
    isigma = sqrtf((1.0/(nsamples-1))*itotal);

    return rsigma+I*isigma;
}
void set_level_occupancy(complex float *input, int nsamples, float *new_gain) {

    float percentage = 0.0;
    float occupancy = 17.0;
    float limit = 0.00001;
    float step = 0.001;
    int i = 0;
    float gain = *new_gain;

    float percentage_clipped = 100;
    while (percentage_clipped > 0 && percentage_clipped > limit) {
        int count = 0;
        int clipped = 0;
        for (i=0;i<nsamples;i++) {
            if (gain*creal(input[i]) >= 0 && gain*creal(input[i]) < 64) {
                count++;
            }
            if (fabs(gain*creal(input[i])) > 127) {
                clipped++;
            }
        }
        percentage_clipped = ((float) clipped/nsamples) * 100;
        if (percentage_clipped < limit) {
            gain = gain + step;
        }
        else {
            gain = gain - step;
        }
        percentage = ((float)count/nsamples)*100.0;
        fprintf(stdout,"Gain set to %f (linear)\n",gain);
        fprintf(stdout,"percentage of samples in the first 64 (+ve) levels - %f percent \n",percentage);
        fprintf(stdout,"percentage clipped %f percent\n",percentage_clipped);
    }
    *new_gain = gain;
}

void get_mean_complex(complex float *input, int nsamples, float *rmean,float *imean, complex float *cmean) {

    int i=0;
    float rtotal = 0;
    float itotal = 0 ;
    complex float ctotal = 0 + I*0.0;
    for (i=0;i<nsamples;i++){
        rtotal = rtotal+crealf(input[i]);
        itotal = itotal+cimagf(input[i]);
        ctotal = ctotal + input[i];
    }
    *rmean=rtotal/nsamples;
    *imean=itotal/nsamples;
    *cmean=ctotal/nsamples;

}
void normalise_complex(complex float *input, int nsamples, float scale) {

    int i=0;

    for (i=0;i<nsamples;i++){
        input[i]=input[i]*scale;
    }

}

void flatten_bandpass(int nstep, int nchan, int npol, void *data, float *scales,float *offsets,int new_var, int iscomplex,int normalise,int update,int clear,int shutdown) {
    // putpose is to generate a mean value for each channel/polaridation

    int i=0,j=0;;
    int p=0;
    float *data_ptr = NULL;

    static float **band;

    static float **chan_min;

    static float **chan_max;


    static int setup = 0;

    if (setup == 0) {
        band = (float **) calloc (npol,sizeof(float *));
        chan_min = (float **) calloc (npol,sizeof(float *));
        chan_max = (float **) calloc (npol,sizeof(float *));
        for (i=0;i<npol;i++) {
            band[i] = (float *) calloc(nchan,sizeof(float));
            chan_min[i] = (float *) calloc(nchan,sizeof(float));
            chan_max[i] = (float *) calloc(nchan,sizeof(float));
        }
        setup = 1;
    }

    if (update) {
        for (p = 0;p<npol;p++) {
            for (j=0;j<nchan;j++){

                band[p][j] = 0.0;
            }
        }

        if (iscomplex == 0) {
            data_ptr = (float *) data;

            for (i=0;i<nstep;i++) {
                for (p = 0;p<npol;p++) {
                    for (j=0;j<nchan;j++){


                        if (i==0) {
                            chan_min[p][j] = *data_ptr;
                            chan_max[p][j] = *data_ptr;
                        }
                        band[p][j] += fabsf(*data_ptr);
                        if (*data_ptr < chan_min[p][j]) {
                            chan_min[p][j] = *data_ptr;
                        }
                        else if (*data_ptr > chan_max[p][j]) {
                            chan_max[p][j] = *data_ptr;
                        }
                        data_ptr++;
                    }
                }

            }
        }
        else {
            complex float  *data_ptr = (complex float *) data;
            for (i=0;i<nstep;i++) {
                for (p = 0;p<npol;p++) {
                    for (j=0;j<nchan;j++){

                        band[p][j] += cabsf(*data_ptr);
                        data_ptr++;
                    }
                }

            }

        }

    }
    // set the offsets and scales - even if we are not updating ....

    float *out=scales;
    float *off = offsets;
    for (p = 0;p<npol;p++) {
        for (j=0;j<nchan;j++){

            // current mean
            *out = ((band[p][j]/nstep))/new_var; // removed a divide by 32 here ....
            //fprintf(stderr,"Channel %d pol %d mean: %f normaliser %f (max-min) %f\n",j,p,(band[p][j]/nstep),*out,(chan_max[p][j] - chan_min[p][j]));
            out++;
            *off = 0.0;

            off++;

        }
    }
    // apply them to the data

    if (normalise) {

        data_ptr = (float *) data;

        for (i=0;i<nstep;i++) {
            float *normaliser = scales;
            float *off  = offsets;
            for (p = 0;p<npol;p++) {
                for (j=0;j<nchan;j++){

                    *data_ptr = ((*data_ptr) - (*off))/(*normaliser); // 0 mean normalised to 1
                    //fprintf(stderr,"%f %f %f\n",*data_ptr,*off,*normaliser);
                    off++;
                    data_ptr++;
                    normaliser++;
                }
            }

        }
    }

    // clear the weights if required

    if (clear) {

        float *out=scales;
        float *off = offsets;
        for (p = 0;p<npol;p++) {
            for (j=0;j<nchan;j++){

                // reset
                *out = 1.0;



                out++;
                *off = 0.0;

                off++;

            }
        }
    }

    // free the memory
    if (shutdown) {
        for (i=0;i<npol;i++) {
            free(band[i]);
            free(chan_min[i]);
            free(chan_max[i]);
        }


        free(band);
        free(chan_min);
        free(chan_max);
        setup = 0;
    }
}



int read_pfb_call(char *in_name, int expunge, char *heap) {


    char out_file[MAX_COMMAND_LENGTH];


    int fd_in = open(in_name,O_RDONLY);

    if (fd_in < 0) {
        fprintf(stderr,"Failed to open %s:%s\n",in_name,strerror(errno));
        return -1;
    }
    else {
        fprintf(stderr,"Opening %s for input\n",in_name);
    }
    int fd_out = 0;
    if (heap == NULL) {

        sprintf(out_file,"/dev/shm/%s.working",in_name);

        fprintf(stdout,"\nConverting %s to %s\n",in_name,out_file);

        if ((access(out_file,F_OK) != -1) && (!expunge)){
            return 1;
        }

        open(out_file,O_CREAT | O_TRUNC | O_WRONLY | O_SYNC, 0666);

        if (fd_out < 0) {
            fprintf(stderr,"Failed to open %s:%s\n",out_file,strerror(errno));
            return -1;
        }
    }

    if ((default_read_pfb_call(fd_in,fd_out,heap)) < 0){
        fprintf(stderr,"Error in default_read_pfb\n");
        close(fd_in);
        if (fd_out > 0)
            close(fd_out);
        return -1;
    }
    else {
        close(fd_in);
        if (fd_out > 0)
            close(fd_out);
        return 1;
    }

}

float get_weights(int nstation, int nchan, int npol, int weights, char *weights_file, double **array){


    float wgt_sum=0;

    FILE *wgts = NULL;

    if (*array == NULL) {
        *array = (double *) calloc(nstation*npol,sizeof(double));
    }

    double *weights_array = *array;


    if (weights == 1) {
        fprintf(stdout,"Open weights file %s\n",weights_file);
        wgts = fopen(weights_file,"r");
        if (wgts==NULL) {
            fprintf(stderr,"Cannot open weights file %s:%s\n",weights_file,strerror(errno));
            return -1;
        }
        else {
            int count = 0;
            while (!feof(wgts)) {
                // fprintf(stderr,"count: %d: nstation %d npol %d\n",count,nstation,npol);
                if (count < nstation*npol) {
                    fscanf(wgts,"%lf\n",&weights_array[count]);
                    wgt_sum = wgt_sum + pow(weights_array[count],2);
                    // fprintf(stderr,"wgt_sum: %f\n",wgt_sum);
                }
                else {
                    break;
                }
                count++;
            }
            if (count != nstation*npol) {
                fprintf(stderr,"Mismatch between weights and antennas - check weight file\n");
                fclose(wgts);
                return -1;
            }
            fclose(wgts);

        }
         fprintf(stdout,"Closed weights file %s\n",weights_file);
    }
    else if (weights == 0) {
        int count = 0;
        for (count = 0 ;count < nstation*npol; count++) {
            weights_array[count]=1.0;
        }
        wgt_sum = nstation*npol;
    }


    return wgt_sum;
}

int get_phases(int nstation,int nchan,int npol,char *phases_file, double **weights, double ***phases_array, complex double ***complex_weights_array,long checkpoint) {

    fprintf(stdout, "Getting phases: checkpoint = %ld\n", checkpoint);

    int count = 0;
    FILE *phases = NULL;
    int ch=0;

    int rval = 0;

    if (*phases_array == NULL) {
        *phases_array = (double **) calloc(nstation*npol,sizeof(double *));

        for (count = 0;count < nstation*npol;count++) {
            (*phases_array)[count] = (double *) calloc(nchan,sizeof(double));

        }

    }

    if (*complex_weights_array == NULL) {

        *complex_weights_array = (complex double **) calloc(nstation*npol,sizeof(complex double *));

        for (count = 0;count < nstation*npol;count++) {

            (*complex_weights_array)[count] = (complex double *) calloc(nchan,sizeof(complex double));
        }

    }
    if (phases_file != NULL) {
        fprintf(stdout,"Open phases file %s\n",phases_file);
        phases = fopen(phases_file,"r");

        if (phases==NULL) {
            fprintf(stderr,"Cannot open phases file %s:%s\n",phases_file,strerror(errno));
            return -1;
        }
        else {

            if (checkpoint != 0) {
                fseek(phases,checkpoint,SEEK_SET);
            }

            count = 0;

            while ((count < nstation*npol) && !feof(phases)) {
                for (ch=0;ch<nchan;ch++) {
                    rval = fscanf(phases,"%lf\n",&(*phases_array)[count][ch]);
                   // fprintf(stdout,"Phases: %d %d %lf\n",count,ch,(*phases_array)[count][ch]);
                }
                if (rval != 1)
                    break;

                count++;
            }

            if (count != nstation*npol) {
                if (feof(phases))
                    fprintf(stderr,"Unexpected end of file in phases - found %d and expected %d!\n",count,nstation*npol);
                else
                    fprintf(stderr,"Mismatch between phases and antennas - check phases file\n");
                fclose(phases);
                return -1;
            }
            else {
                checkpoint = ftell(phases);
                fprintf(stdout,"Checkpoint set to %ld\n",checkpoint);
            }

            fclose(phases);
        }

        fprintf(stdout,"Closed phases file %s\n",phases_file);
    }

    for (count = 0 ;count < nstation*npol; count++) {
        for (ch=0;ch<nchan;ch++) {
            if (phases_file == NULL) {
                (*phases_array)[count][ch] = 0.0;
                (*complex_weights_array)[count][ch] = (*weights)[count]*1.0;
            }
            else {
                (*complex_weights_array)[count][ch] = (*weights)[count] * cexp(I*(*phases_array)[count][ch]);
               // fprintf(stdout,"Complex weight for station[%d] channel[%d] is %lf %lf\n",count,ch,creal((*complex_weights_array)[count][ch]),cimag((*complex_weights_array)[count][ch]));
            }
        }
    }
    return checkpoint;

}
int get_jones(int nstation,int nchan,int npol,char *jones_file,complex double ***invJi, long checkpoint) {

    int i=0;
    FILE *jones = NULL;
    int rval=0;


    if (*invJi == NULL) {
        *invJi = (complex double **) calloc(nstation, sizeof(complex double *)); // Gain in Desired Direction ..... da da da dum.....
        for (i = 0; i < nstation; i++) { //
            (*invJi)[i] =(complex double *) malloc(npol * npol * sizeof(complex double)); //
            if ((*invJi)[i] == NULL) { //
                fprintf(stderr, "malloc failed for J[i]\n"); //
                return -1; //
            } //
        }
    }


    complex double Ji[4];
    jones = fopen(jones_file,"r");
    if (jones==NULL) {
        fprintf(stderr,"Cannot open Jones matrix file %s:%s\n",jones_file,strerror(errno));
        usage();
    }
    else {
        if (checkpoint !=0) {
            fseek(jones,checkpoint,SEEK_SET);
        }

        int count = 0;


        while (count < nstation) {
            for (i=0 ; i < 4; i++) {
                float re,im;
                rval = fscanf(jones,"%f %f ",&re,&im);

                Ji[i] = re - I*im; // the RTS conjugates the sky so beware ....

            }
            if (rval != 2)
                break;

            double Fnorm = 0;
            int j=0;
            for (j=0; j < 4;j++) {
                Fnorm += (double) Ji[j] * conj(Ji[j]);
            }
            Fnorm = sqrt(Fnorm);
            // fprintf(stderr,"Fnorm (Ji) = (%d) %f\n",count,Fnorm);
            if (Fnorm != 0) {
                for (j=0; j < 4;j++) {
                    Ji[j] = Ji[j]/Fnorm;
                }

                inv2x2(Ji,(*invJi)[count]);
            }
            else {

                (*invJi)[count][0] = 0.0 + I*0;
                (*invJi)[count][1] = 0.0 + I*0;
                (*invJi)[count][2] = 0.0 + I*0;
                (*invJi)[count][3] = 0.0 + I*0;

            }
            Fnorm = 0;
            for (j=0; j < 4;j++) {
                Fnorm += (double) (*invJi)[count][j] * conj((*invJi)[count][j]);
            }
            Fnorm = sqrt(Fnorm);
           //            fprintf(stderr,"Fnorm = (%d) %f\n",count,sqrt(Fnorm));
//            for (j=0; j < 4;j++) {
//                fprintf(stderr,"(%d,%d) %f %f",count,j,creal((*invJi)[count][j]),cimag((*invJi)[count][j]) );
 //           }
//            fprintf(stderr,"\n");

            count++;
        }

        if (count != nstation) {
            fprintf(stderr,"Mismatch between Jones matrices and antennas - check Jones file\n");
            fclose(jones);
            return -1;
        }
        else {
            checkpoint = ftell(jones);
        }

        fclose(jones);
    }

    return checkpoint;


}


/*****************
 * MAIN FUNCTION *
 *****************/


int main(int argc, char **argv) {

    // Profiling the code
    clock_t tbegin, tend; // For profiling the code
    double tprelude = 0.0;
    double tpreomp = 0.0;
    double tomp = 0.0;
    double tpostomp = 0.0;
    double tcoda = 0.0;

    tbegin = clock(); // Begin timing "tprelude"

    int dir_index;
    int ii;
    double dtmp;
    int c = 0;
    int ch=0;
    int chan = 0; // 0-offset coarse channel number to process

    unsigned long int begin = 0;
    unsigned long int end   = 0;

    int weights = 0;
    int apply_jones = 0;
    char rec_channel[4]; // 0 - 255 receiver 1.28MHz channel


    char *weights_file = NULL;
    char *phases_file = NULL;
    char *jones_file = NULL;
    char *psrfits_file = NULL;

    char *gains_file = NULL;

    char *obsid;
    char *procdirroot=NULL;
    char *datadirroot=NULL;
    char *extn=NULL;
    char procdir[256];
    char **filenames;
    int read_stdin = 0;
    int nfiles = 0;
    int expunge = 0;
    int read_files = 0;

    int sample_rate = 10000;
    int fringe_int = 0;

    int edge = 0;
    int fft_mode = 1;

    int nchan = 128;

    nfrequency = nchan;
    nstation = 128;
    npol = 2;
    int outpol = 4;
    int summed_polns = 0;

    if (argc > 1) {

        while ((c = getopt(argc, argv, "a:b:c:d:D:e:f:hj:n:N:o:r:Vw:X")) != -1) {
            switch(c) {

                case 'a':
                    nstation = atoi(optarg);
                    break;
                case 'b':
                    begin = atol(optarg);
                    break;
                case 'c':
                    phases_file = strdup(optarg);
                    break;
                case 'd':
                    datadirroot = strdup(optarg);
                    break;
                case 'D':
                    procdirroot = strdup(optarg);
                    break;
                case 'e':
                    end = atol(optarg);
                    break;
                case 'f':
                    psrfits_file = strdup(optarg);
                    break;
                case 'h':
                    usage();
                    exit(0);
                    break;
                case 'j':
                    apply_jones = 1;
                    jones_file = strdup(optarg);
                    break;
                case 'n':
                    nchan = atoi(optarg);
                    break;
                case 'N':
                    chan = atoi(optarg);
                    break;
                case 'o':
                    obsid = strdup(optarg);
                    break;
                case 'r':
                    sample_rate = atoi(optarg);
                    break;
                case 'V':
                    printf("%s\n", MAKE_BEAM_VERSION);
                    exit(0);
                    break;
                case 'w':
                    weights=1;
                    weights_file = strdup(optarg);
                    break;
                case 'X':
                    expunge = 1;
                    break;
                default:
                    usage();
                    exit(EXIT_FAILURE);
            }
        }
    }

    fprintf(stderr,"Starting ...\n");

    switch (nchan) {
        case 88:
            edge = 20;
            fft_mode = 2;
            break;
        case 128:
            edge = 0;
            fft_mode = 1;
        default:
            fft_mode = 1;
            edge = 0;
    }

    if (procdirroot) {

        // Pick up the correct phases files

        dir_index = chan + 1;
        sprintf(procdir,"%s%02d",procdirroot,dir_index);

        fprintf(stdout,"Will look for processing files in %s\n",procdir);
        char pattern[256];


        /* update the phases and weights file names */
        if (weights_file) {
            sprintf(pattern,"%s/%s",procdir,weights_file);
            free(weights_file);
            weights_file=strdup(pattern);
            fprintf(stdout,"weights_file: %s\n",weights_file);
        }
        if (phases_file) {
            sprintf(pattern,"%s/%s",procdir,phases_file);
            free(phases_file);
            phases_file=strdup(pattern);
            fprintf(stdout,"phases_file: %s\n",phases_file);
        }
        if (jones_file) {
            sprintf(pattern,"%s/%s",procdir,jones_file);
            free(jones_file);
            jones_file=strdup(pattern);
            fprintf(stdout,"jones_file: %s\n",jones_file);
        }
        if (gains_file) {
            sprintf(pattern,"%s/%s",procdir,gains_file);
            free(gains_file);
            gains_file=strdup(pattern);
            fprintf(stdout,"gains_file: %s\n",gains_file);
        }
        fprintf(stdout, "\n");
        sprintf(pattern,"%s/%s",procdir,"channel");

        FILE *tmp;
        tmp = fopen(pattern,"r");

        if (tmp) {
            fscanf(tmp,"%s",rec_channel);
            fclose(tmp);
        }
        else {
            perror("Cannot find channel file - version missmatch - update get_delays");
            exit(EXIT_FAILURE);
        }

        if (datadirroot) {

            // Generate list of files to work on

            // Calculate the number of files
            nfiles = end - begin + 1;
            if (nfiles <= 0) {
                fprintf(stderr,"Cannot beamform on %d files (between %lu and %lu)\n", nfiles, begin, end);
                exit(EXIT_FAILURE);
            }

            // Allocate memory for the file name list
            filenames = (char **)malloc( nfiles*sizeof(char *) );

            // Allocate memory and write filenames
            int second;
            unsigned long int timestamp;
            for (second = 0; second < nfiles; second++) {
                timestamp = second + begin;
                filenames[second] = (char *)malloc( MAX_COMMAND_LENGTH*sizeof(char) );
                sprintf( filenames[second], "%s/%s_%ld_ch%s.dat", datadirroot, obsid, timestamp, rec_channel );
                //sprintf( filenames[second], "%s_%ld_ch%s.dat", obsid, timestamp, rec_channel );
            }
            fprintf( stderr, "Opening files from %s to %s\n", filenames[0], filenames[nfiles-1] );

        }
    }


    size_t bytes_per_spec=0;

    double *weights_array = NULL;
    double **phases_array = NULL;

    complex double **complex_weights_array = NULL;
    complex double **invJi = NULL;
    complex double *antenna_gains = NULL;

   // FILE *wgts = NULL;
   // FILE *phases = NULL;
   // FILE *jones = NULL;

    // these are only used if we are prepending the fitsheader
    FILE *fitsheader = NULL;
    struct psrfits pf;

    // these are the file positions of the Jones and Phases files

    long jones_pos=0;
    long phase_pos=0;

    long new_jones_pos=0;
    long new_phase_pos=0;

    int get_new_jones=1; // boolean: 1 iff next second's worth of jones are to be retrieved
    int get_new_phase=1; // boolean: 1 iff next second's worth of phase are to be retrieved

    float wgt_sum = get_weights(nstation,nchan,npol,weights,weights_file, &weights_array); // this is now a flag file

    if (wgt_sum == 0 || wgt_sum == -1) {
        fprintf(stderr,"Zero weight sum or error on read -- check %s\n",weights_file);
        exit(EXIT_FAILURE);
    }

    // Get first second's worth of phases and Jones matrices

    // PHASES:
    new_phase_pos = get_phases(nstation, nchan, npol, phases_file,
                               &weights_array, &phases_array,
                               &complex_weights_array, phase_pos);
    phase_pos = new_phase_pos;
    get_new_phase = 0;

    // JONES:
    if (apply_jones) {
        new_jones_pos = get_jones(nstation, nchan, npol, jones_file,
                                  &invJi, jones_pos);
        jones_pos = new_jones_pos;
        get_new_jones = 0;
    }

    if (phase_pos < 0 || jones_pos < 0) {
        fprintf(stderr,"Failed to parse the correct number of Jones matrices or phases\n");
        exit(EXIT_FAILURE);
    }

    char proc_psrfits_file[1024];
    sprintf(proc_psrfits_file,"%s/%s",procdir,psrfits_file);
    fitsheader=fopen(proc_psrfits_file,"r");
    if (fitsheader != NULL) {
        fread((void *)&pf,sizeof(pf),1,fitsheader);
    }
    else {
        fprintf(stderr,"Cannot load fitsheader - check %s\n",proc_psrfits_file);
        exit(EXIT_FAILURE);

    }
    fclose(fitsheader);
    // now we need to create a fits file with this header


    // We need to change a few things to pick up the type of beam we are:

    // npols + nbits and whether pols are added
    pf.filenum = 0;             // This is the crucial one to set to initialize things
    pf.rows_per_file = 200;     // I assume this is a max subint issue
    
    pf.hdr.npol = outpol;
    pf.hdr.summed_polns = summed_polns;
    pf.hdr.nchan = nchan;

    // Specify psrfits data type
    pf.hdr.nbits = 8;
    pf.sub.FITS_typecode = TBYTE;

    bytes_per_spec = pf.hdr.nbits * pf.hdr.nchan * pf.hdr.npol/8;
    pf.sub.bytes_per_subint = (pf.hdr.nbits * pf.hdr.nchan *
                               pf.hdr.npol * pf.hdr.nsblk) / 8;
    // Create and initialize the subint arrays
    pf.sub.dat_freqs = (float *)malloc(sizeof(float) * pf.hdr.nchan);
    pf.sub.dat_weights = (float *)malloc(sizeof(float) * pf.hdr.nchan);
    dtmp = pf.hdr.fctr - 0.5 * pf.hdr.BW + 0.5 * pf.hdr.df;
    for (ii = 0 ; ii < pf.hdr.nchan ; ii++) {
        pf.sub.dat_freqs[ii] = dtmp + ii * pf.hdr.df;
        pf.sub.dat_weights[ii] = 1.0;
    }
    pf.sub.dat_offsets = (float *)malloc(sizeof(float) * pf.hdr.nchan * pf.hdr.npol); // definitely needed for 8 bit numbers
    pf.sub.dat_scales = (float *)malloc(sizeof(float) * pf.hdr.nchan * pf.hdr.npol);
    for (ii = 0 ; ii < pf.hdr.nchan * pf.hdr.npol ; ii++) {
        pf.sub.dat_offsets[ii] = 0.0;
        pf.sub.dat_scales[ii] = 1.0;
    }

    pf.sub.data = (unsigned char *)malloc(pf.sub.bytes_per_subint);
    pf.sub.rawdata = pf.sub.data;

    sprintf(pf.basefilename,"%s_%s_%02d",pf.hdr.project_id,pf.hdr.source,dir_index);

    int nspec = 1;
    size_t items_to_read = nstation*npol*nchan*2;
    float *spectrum = (float *) calloc(nspec*nchan*outpol,sizeof(float));
    float *incoherent_sum = (float *) calloc(nspec*nchan,sizeof(float));

    complex float **fringe = calloc(nchan,sizeof(complex float));

    complex float **stopped_fringe = calloc(nchan,sizeof(complex float));
    complex float **beam = calloc(nchan,sizeof(complex float *));
    int stat = 0;

    for (stat = 0; stat < nchan;stat++) {
        beam[stat] = (complex float *) calloc(nstation*npol,sizeof(complex float));
        fringe[stat] = (complex float *) calloc(2*npol,sizeof(complex float));
        stopped_fringe[stat] = (complex float *) calloc(2*npol,sizeof(complex float));
    }

    float *noise_floor = calloc(nchan*npol*npol,sizeof(float));
    complex float *pol_X = (complex float *) calloc(nchan+2*edge,sizeof(complex float));
    complex float *pol_Y = (complex float *) calloc(nchan+2*edge,sizeof(complex float));

    char *buffer = (char *) malloc(nspec*items_to_read*sizeof(int8_t));
    char *heap = NULL;

    size_t heap_step = 0;

    heap = (char *) malloc(nspec*items_to_read*sample_rate);

    assert(heap);



    float *data_buffer_psrfits = NULL;

    float *filter_buffer_X = NULL; // only needed for full PFB inversion (fft_mode == 3)
    float *filter_buffer_Y = NULL; // only needed for full PFB inversion (fft_mode == 3)

    float *filter_buffer_X_ptr = NULL; // only needed for full PFB inversion (fft_mode == 3)
    float *filter_buffer_Y_ptr = NULL; // only needed for full PFB inversion (fft_mode == 3)

    float *filter_out_X = NULL; // only needed for full PFB inversion (fft_mode == 3)
    float *filter_out_Y = NULL; // only needed for full PFB inversion (fft_mode == 3)

    float *filter_out_X_ptr = NULL; // only needed for full PFB inversion (fft_mode == 3)
    float *filter_out_Y_ptr = NULL; // only needed for full PFB inversion (fft_mode == 3)

    int8_t *out_buffer_8_psrfits = NULL;

    data_buffer_psrfits = (float *) valloc(nchan * outpol * pf.hdr.nsblk*sizeof(float));
    out_buffer_8_psrfits = (int8_t *) malloc(outpol*nchan* pf.hdr.nsblk*sizeof(int8_t));
    if (data_buffer_psrfits == NULL){
        fprintf(stderr,"Failed to allocate data buffer\n");
        exit(EXIT_FAILURE);
    }

    int set_levels = 1;
    int specnum=0;
    int integ=0;
    int index=0;
    int finished = 0;
    size_t offset_out_psrfits = 0;
    size_t offset_in_psrfits  = 0;

    float gain=1.0;
    int file_no = 0;
    FILE *fp = NULL;

    char working_file[MAX_COMMAND_LENGTH];

    tend = clock();
    tprelude = (double)(tend-tbegin)/CLOCKS_PER_SEC;

    while(finished == 0) { // keep going indefinitely

        tbegin = clock(); // Start timing "tpreomp"

        if (read_stdin) {
            unsigned int rtn = fread(buffer,items_to_read*sizeof(int8_t),nspec,stdin);
            if (feof(stdin) || rtn != nspec) {
                fprintf(stderr,"make_beam finished:\n");
                finished = 1;
                continue;
            }
        }
        else if (read_files) {
            if (file_no >= nfiles) { // finished file list
                fprintf(stderr,"make_beam finished:\n");
                finished = 1;
                continue;
            }

            if (fp == NULL) { // need to open the next file

                if ((read_pfb_call(filenames[file_no],expunge,heap)) < 0)
                    break; // Exit from while loop

                sprintf(working_file,"/dev/shm/%s.working",filenames[file_no]);

                fp = fopen(working_file, "r");

                if (fp == NULL) {
                    fprintf(stderr,"Failed to open file %s\n", working_file);
                    break; // Exit from while loop
                }
                else {
                  fprintf(stderr,"Opened file %s\n", working_file);
                }

                continue;
            }
            else { // file already open, read next chunk of data
                unsigned int rtn = fread(buffer,items_to_read*sizeof(int8_t),nspec,fp);
                if (feof(fp) || rtn != nspec) {
                    fclose(fp);
                    fp = NULL;
                    if (expunge == 1) {
                        unlink(working_file);
                    }
                    fprintf(stderr,"finished file %s\n", filenames[file_no]);
                    file_no++;
                    continue;
                }
            }
        }
        if (heap_step == 0) {

            if (file_no >= nfiles) { // finished file list
                fprintf(stderr,"make_beam finished:\n");
                finished = 1;
                continue;
            }

            if ((read_pfb_call(filenames[file_no],expunge,heap)) < 0)
                break; // Exit from while loop

        }
        if (heap_step < sample_rate) {
            memcpy(buffer,heap+(items_to_read*heap_step),items_to_read);

            heap_step++;
           // fprintf(stderr,"make_beam copied %d steps out if the heap\n",heap_step);
        }
        else {
            heap_step = 0;
            file_no++;

            if (file_no >= nfiles) { // finished file list
                fprintf(stderr,"make_beam finished:\n");
                finished = 1;
                continue;
            }

            if ((read_pfb_call(filenames[file_no],expunge,heap)) < 0)
                break; // Exit from while loop

            memcpy(buffer,heap+(items_to_read*heap_step),items_to_read);
            heap_step++;

        }

        int stat = 0;
        bzero(spectrum,(nchan*outpol*sizeof(float)));
        for (stat=0;stat<nchan;stat++) {
            bzero(beam[stat],(nstation*npol*sizeof(complex float)));
        }
        bzero(incoherent_sum,(nchan*sizeof(float)));
        bzero(noise_floor,(nchan*npol*npol*sizeof(float)));

        if (offset_in_psrfits == 0) {
            bzero(data_buffer_psrfits,(pf.hdr.nsblk*nchan*outpol*sizeof(float)));
        }

        tend = clock();
        tpreomp += (double)(tend-tbegin)/CLOCKS_PER_SEC;

        tbegin = clock(); // Start timing "tomp"

#pragma omp parallel for
        for (index = 0; index < nstation*npol;index = index + 2) {

            for (ch=0;ch<nchan;ch++) {
                int8_t *in_ptr = (int8_t *)buffer + 2*index*nchan + 2*ch;

                complex float e_true[2],e_dash[2];

                e_dash[0] = (float) *in_ptr + I*(float)(*(in_ptr+1));
                e_dash[1] = (float) *(in_ptr+(nchan*2)) + I*(float)(*(in_ptr+(nchan*2)+1)); // next pol is nchan*2 away

                e_true[0] = e_dash[0];
                e_true[1] = e_dash[1];

                if (apply_jones == 0){

                    e_true[0] = e_true[0] * complex_weights_array[index][ch];
                    e_true[1] = e_true[1] * complex_weights_array[index+1][ch];

                }
                else {

                    /* apply the inv(jones) to the e_dash */
                    e_dash[0] = e_dash[0] * complex_weights_array[index][ch];
                    e_dash[1] = e_dash[1] * complex_weights_array[index+1][ch];

                    e_true[0] = invJi[index/npol][0]*e_dash[0] + invJi[index/npol][1]*e_dash[1];
                    e_true[1] = invJi[index/npol][2]*e_dash[0] + invJi[index/npol][3]*e_dash[1];

                }



                noise_floor[ch*npol*npol] += e_true[0] * conj(e_true[0]);
                noise_floor[ch*npol*npol+1] += e_true[0] * conj(e_true[1]);
                noise_floor[ch*npol*npol+2] += e_true[1] * conj(e_true[0]);
                noise_floor[ch*npol*npol+3] += e_true[1] * conj(e_true[1]);


                beam[ch][index] = e_true[0];
                beam[ch][index+1] = e_true[1];

                incoherent_sum[ch] = incoherent_sum[ch] + (weights_array[index]*weights_array[index]*(e_true[0] * conj(e_true[0])))/wgt_sum;
                incoherent_sum[ch] = incoherent_sum[ch] + (weights_array[index+1]*weights_array[index+1]*(e_true[1] * conj(e_true[1])))/wgt_sum;

            }
        } // end OMP for loop

        tend = clock();
        tomp += (double)(tend-tbegin)/CLOCKS_PER_SEC;

        tbegin = clock(); // Start timing "tpostomp"

        // detect the beam or prep from invert_pfb
        // reduce over each channel for the beam
        // do this by twos
        int polnum = 0;
        int step = 0;
        for (ch=0;ch<nchan;ch++) {
            for (polnum = 0; polnum < npol; polnum++) {
                int next_good = 2;
                int stride = 4;

                while (next_good < nstation*npol) {
                    for (step=polnum;step<nstation*npol;step=step+stride) {
                        beam[ch][step] = beam[ch][step] + beam[ch][step+next_good];
                    }
                    stride = stride * 2;
                    next_good = next_good *2;
                }
            }
        }

        int index = 0;
        int product;
        for (product = 0; product < outpol; product++) {
            for (ch=0;ch<nchan;ch++,index++) {
                // Looking at the dspsr loader the expected order is <ntime><npol><nchan>
                // so for a single timestep we do not have to interleave - I could just stack these

                // So coherency or Stokes?
                if (product == 0) {
                    // Stokes I
                    spectrum[index] = (beam[ch][0] * conj(beam[ch][0]) - noise_floor[ch*npol*npol])/wgt_sum;
                    spectrum[index] = spectrum[index] + ((beam[ch][1] * conj(beam[ch][1]) - noise_floor[ch*npol*npol+3])/wgt_sum);
                }
                else if (product == 1) {
                    // This will be Stokes Q
                    spectrum[index] = (beam[ch][0] * conj(beam[ch][0]) - noise_floor[ch*npol*npol])/wgt_sum;
                    spectrum[index] = spectrum[index] - ((beam[ch][1] * conj(beam[ch][1]) - noise_floor[ch*npol*npol+3])/wgt_sum);

                }
                else if (product == 2) {
                    // This will be Stokes U
                    complex double temp = (beam[ch][0]*conj(beam[ch][1]) - noise_floor[ch*npol*npol+1])/wgt_sum;
                    spectrum[index] = 2.0 * creal(temp);
                }
                else if (product == 3) {
                    // This will be Stokes V
                    complex double temp = (beam[ch][0]*conj(beam[ch][1]) - noise_floor[ch*npol*npol+1])/wgt_sum;
                    spectrum[index] = -2.0 * cimag(temp);;
                }
            }
        }

        if (!finished) {

            if (offset_out_psrfits < pf.sub.bytes_per_subint) {

                memcpy((void *)((char *)data_buffer_psrfits + offset_in_psrfits),spectrum,sizeof(float)*nchan*outpol);
                offset_in_psrfits += sizeof(float)*nchan*outpol;

                offset_out_psrfits += bytes_per_spec;

            }

            // If we've arrived at the end of a second's worth of data...
            if (offset_out_psrfits == pf.sub.bytes_per_subint) {

                if (set_levels) {
                    flatten_bandpass(pf.hdr.nsblk,nchan,outpol,data_buffer_psrfits,pf.sub.dat_scales,pf.sub.dat_offsets,32,0,1,1,1,0);
                    set_levels = 0;
                }
                else {
                    flatten_bandpass(pf.hdr.nsblk,nchan,outpol,data_buffer_psrfits,pf.sub.dat_scales,pf.sub.dat_offsets,32,0,1,1,1,0);
                }
                float2int8_trunc(data_buffer_psrfits, pf.hdr.nsblk*nchan*outpol, -126.0, 127.0, out_buffer_8_psrfits);
                int8_to_uint8(pf.hdr.nsblk*nchan*outpol,128,(char *) out_buffer_8_psrfits);
                memcpy(pf.sub.data,out_buffer_8_psrfits,pf.sub.bytes_per_subint);

                if (psrfits_write_subint(&pf) != 0) {
                    fprintf(stderr,"Write subint failed file exists?\n");
                    break; // Exit from while loop
                }

                pf.sub.offs = roundf(pf.tot_rows * pf.sub.tsubint) + 0.5*pf.sub.tsubint;
                pf.sub.lst += pf.sub.tsubint;;
                fprintf(stderr,"Done.  Wrote %d subints (%f sec) in %d files.  status = %d\n",
                       pf.tot_rows, pf.T, pf.filenum, pf.status);

                get_new_phase = 1;
                if (apply_jones)      get_new_jones = 1;

                offset_out_psrfits = 0;
                offset_in_psrfits = 0;

                fprintf(stdout, "\n"); // To separate out the output between seconds
            }


        }

        // Get the next second's worth of phases / jones matrices, if needed
        if (get_new_phase) {

            new_phase_pos = get_phases(nstation, nchan, npol, phases_file,
                                       &weights_array, &phases_array,
                                       &complex_weights_array, phase_pos);

            if (new_phase_pos == -1)
                break; // Exit from while loop

            phase_pos = new_phase_pos;
            get_new_phase = 0;
            //fprintf(stderr,"new phase checkpoint=%ld\n",new_phase_pos);
        }
        if (get_new_jones) {

            new_jones_pos = get_jones(nstation, nchan, npol, jones_file,
                                      &invJi, jones_pos);

            if (new_jones_pos == -1)
                break; // Exit from while loop

            jones_pos = new_jones_pos;
            get_new_jones = 0;
            //fprintf(stderr,"new jones checkpoint=%ld\n",new_jones_pos);

        }

        if (finished) {

            fwrite(spectrum,sizeof(float),nchan,stdout);

        }
        specnum++;

        tend = clock();
        tpostomp += (double)(tend-tbegin)/CLOCKS_PER_SEC;

    } // end while loop

    tbegin = clock(); // Start timing "tcoda"

    if (fp != NULL) {
        //cleanup
        fclose(fp);
        if (expunge)
            unlink(working_file);
    }

    if (pf.status == 0) {
        /* now we have to correct the STT_SMJD/STT_OFFS as they will have been broken by the write_psrfits*/
        int itmp = 0;
        int itmp2 = 0;
        double dtmp = 0;
        int status = 0;

        //fits_open_file(&(pf.fptr),pf.filename,READWRITE,&status);

        fits_read_key(pf.fptr, TDOUBLE, "STT_OFFS", &dtmp, NULL, &status);
        fits_read_key(pf.fptr, TINT, "STT_SMJD", &itmp, NULL, &status);
        fits_read_key(pf.fptr, TINT, "STT_IMJD", &itmp2, NULL, &status);

        if (dtmp > 0.5) {
            itmp = itmp+1;
            if (itmp == 86400) {
                itmp = 0;
                itmp2++;
            }
        }
        dtmp = 0.0;

        fits_update_key(pf.fptr, TINT, "STT_SMJD", &itmp, NULL, &status);
        fits_update_key(pf.fptr, TINT, "STT_IMJD", &itmp2, NULL, &status);
        fits_update_key(pf.fptr, TDOUBLE, "STT_OFFS", &dtmp, NULL, &status);

        //fits_close_file(pf.fptr, &status);
        fprintf(stderr,"Done.  Wrote %d subints (%f sec) in %d files.  status = %d\n",
               pf.tot_rows, pf.T, pf.filenum, pf.status);

        // free some memory
        flatten_bandpass(pf.hdr.nsblk,nchan,outpol,data_buffer_psrfits,pf.sub.dat_scales,pf.sub.dat_offsets,32,0,0,0,0,1);

    }

    // Free up memory for filenames
    if (procdirroot && datadirroot) {
        int second;
        for (second = 0; second < nfiles; second++)
            free( filenames[second] );
        free( filenames );
    }

    tend = clock();
    tcoda = (double)(tend-tbegin)/CLOCKS_PER_SEC;

    fprintf( stdout, "# omp tprelude tpreomp tomp tpostomp tcoda\n" );
    fprintf( stdout, "%e %e %e %e %e\n", tprelude, tpreomp, tomp, tpostomp, tcoda );

}
