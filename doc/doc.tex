\documentclass{article}

\usepackage{fullpage}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{color}

\author{Sam McSweeney}
\title{Miscellaneous Documentation for the Beamformer}

\begin{document}

\maketitle

\tableofcontents

\section{The ordering of the input files}

The heirarchy of the input data files is, nominally,
\begin{equation}
    [\text{time sample}][\text{channel}][\text{antenna}][\text{polarisation}][\text{complexity}].
\end{equation}
For a second's worth of data in a single file, we have:
\begin{equation}
    10000 \times 128 \times 128 \times 2 \times 2\quad (\times 4\,\text{bits}) = 327680000\,\text{bytes}
\end{equation}

However, the numbering of the antennas and the polarisations as the data come out of the PFB (and after the \texttt{recombine} stage) are different to the ordering assumed by the beamformer.
The $128 \times 2 = 256$ possible antenna/polarisation pairs are mapped as follows.
\begin{table}[!h]
    \centering
    \begin{tabular}{ccc|ccc}
        \multicolumn{3}{c}{Data file} & \multicolumn{3}{c}{Beamformer} \\
        ant & pol & index & index & ant & pol \\
        \hline
        0 & 0 & 0 &  0 &  0 & 0 \\
        0 & 1 & 1 & 16 &  8 & 0 \\
        1 & 0 & 2 & 32 & 16 & 0 \\
        1 & 1 & 3 & 48 & 24 & 0 \\
        2 & 0 & 4 &  1 &  0 & 1 \\
        2 & 1 & 5 & 17 &  8 & 1 \\
        3 & 0 & 6 & 33 & 16 & 1 \\
        3 & 1 & 7 & 49 & 24 & 1 \\
        4 & 0 & 8 &  2 &  1 & 0 \\
        \vdots & \vdots & \vdots & \vdots & \vdots & \vdots \\
        32 & 0 & 64 &  64 & 32 & 0 \\
        32 & 1 & 65 &  80 & 40 & 0 \\
        33 & 0 & 66 &  96 & 48 & 0 \\
        33 & 1 & 67 & 112 & 56 & 0 \\
        34 & 0 & 68 &  65 & 32 & 1 \\
        \vdots & \vdots & \vdots & \vdots & \vdots & \vdots \\
        64 & 0 & 128 & 128 & 64 & 0 \\
        64 & 1 & 129 & 144 & 72 & 0 \\
        65 & 0 & 130 & 160 & 80 & 0 \\
        65 & 1 & 131 & 176 & 88 & 0 \\
        66 & 0 & 132 & 129 & 64 & 1 \\
        \vdots & \vdots & \vdots & \vdots & \vdots & \vdots \\
    \end{tabular}
\end{table}

For efficiency, the beamformer should initially read in the whole second's worth of data in ``data order'', and calculate the index appropriate for a given antenna/polarisation pair as and when needed.
This requires finding the mapping from beamformer indices to data indices.
This becomes easier if we reconsider how we break up the $256$.

\newpage
\noindent If we recast the data file heirarchy\footnote{I'm not sure of the physical bases of this break up---I'm going off Steve Ord's's original code. rec=``Receiver'' and inc=``increment'' are my own terms.} as
\begin{equation}
    [\text{time sample}][\text{channel}][\text{pfb}][\text{receiver}][\text{increment}][\text{complexity}],
\end{equation}
with the sizes being
\begin{equation}
    10000 \times 128 \times 4 \times 16 \times 4 \times 2,
\end{equation}
then we can rewrite the table above as
\begin{table}[!h]
    \centering
    \begin{tabular}{cccc|ccc}
        \multicolumn{4}{c}{Data file} & \multicolumn{3}{c}{Beamformer} \\
        pfb & rec & inc & index & index & ant & pol \\
        \hline
        0 & 0 & 0 & 0 &  0 &  0 & 0 \\
        0 & 0 & 1 & 1 & 16 &  8 & 0 \\
        0 & 0 & 2 & 2 & 32 & 16 & 0 \\
        0 & 0 & 3 & 3 & 48 & 24 & 0 \\
        0 & 1 & 0 & 4 &  1 &  0 & 1 \\
        0 & 1 & 1 & 5 & 17 &  8 & 1 \\
        0 & 1 & 2 & 6 & 33 & 16 & 1 \\
        0 & 1 & 3 & 7 & 49 & 24 & 1 \\
        0 & 2 & 0 & 8 &  2 &  1 & 0 \\
        \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots \\
        1 & 0 & 0 & 64 &  64 & 32 & 0 \\
        1 & 0 & 1 & 65 &  80 & 40 & 0 \\
        1 & 0 & 2 & 66 &  96 & 48 & 0 \\
        1 & 0 & 3 & 67 & 112 & 56 & 0 \\
        1 & 1 & 0 & 68 &  65 & 32 & 1 \\
        \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots \\
        2 & 0 & 0 & 128 & 128 & 64 & 0 \\
        2 & 0 & 1 & 129 & 144 & 72 & 0 \\
        2 & 0 & 2 & 130 & 160 & 80 & 0 \\
        2 & 0 & 3 & 131 & 176 & 88 & 0 \\
        2 & 1 & 0 & 132 & 129 & 64 & 1 \\
        \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots \\
    \end{tabular}
\end{table}

\newpage
\noindent Reversing this table (giving [ant, pol] in terms of [pfb, rec, inc]) yields
\begin{table}[!h]
    \centering
    \begin{tabular}{ccc|cccc}
        \multicolumn{3}{c}{Beamformer} & \multicolumn{4}{c}{Data file} \\
        index & ant & pol & pfb & rec & inc & index \\
        \hline
        0 &  0 & 0 & 0 & 0 & 0 & 0 \\
        1 &  0 & 1 & 0 & 1 & 0 & 4 \\
        2 &  1 & 0 & 0 & 2 & 0 & 8 \\
        3 &  1 & 1 & 0 & 3 & 0 & 12 \\
        4 &  2 & 0 & 0 & 4 & 0 & 16 \\
        \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots \\
        16 &  8 & 0 & 0 & 0 & 1 & 1 \\
        17 &  8 & 1 & 0 & 1 & 1 & 5 \\
        18 &  9 & 0 & 0 & 2 & 1 & 9 \\
        19 &  9 & 1 & 0 & 3 & 1 & 13 \\
        20 & 10 & 0 & 0 & 4 & 1 & 17 \\
        \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots \\
         64 & 32 & 0 & 1 & 0 & 0 & 64 \\
         65 & 32 & 1 & 1 & 1 & 0 & 68 \\
         66 & 33 & 0 & 1 & 2 & 0 & 72 \\
         67 & 33 & 1 & 1 & 3 & 0 & 76 \\
         68 & 34 & 0 & 1 & 4 & 0 & 80 \\
        \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots \\
    \end{tabular}
\end{table}

\noindent From this we can see that the relationships between antenna, polarisation, pfb, receiver, and increment are
\begin{align*}
    \text{pfb} &= \text{ant} / 32 & & \text{(integer divide)} \\
    \text{rec} &= (2\times\text{ant}+\text{pol}) \% 16 & & \text{(modulus operator)} \\
    \text{inc} &= (\text{ant} / 8) \% 4
\end{align*}

\section{Beamformer operations}

By the time the data samples have been read in and are ready to be operated on, the beamformer expects two particular quantites to be already pre-calculated and available.
Both are listed in the table below, and both are calculated in \texttt{get\_delays()}.
\begin{table}[!h]
    \centering
    \begin{tabular}{c|l|l}
        Symbol & Variable name & Type \& Dimensions \\[5pt]
        \hline
        $W = \begin{bmatrix} w_X & 0 \\ 0 & w_Y \end{bmatrix}$ & \texttt{complex\_weights\_array} & \texttt{complex double [nstation*npol][nchan]} \\[12pt]
        $J^{-1} = \begin{bmatrix} j_{XX} & j_{XY} \\ j_{YX} & j_{YY} \end{bmatrix}$ & \texttt{invJi} & \texttt{complex double [nstation][npol*npol]}
    \end{tabular}
\end{table}
The individual components in the matrices $W$ and $J^{-1}$ are complex numbers\footnote{I have avoided using the inverse notation on the components of $J$ for brevity.}. The subscript indices denote polarisation, so that $w_X$, for example, can be thought of as only a function of antenna and channel number, while $j_{XX}$ is just a function of antenna.

\subsection{Beam detection}
A polarisation pair of samples, $D = \begin{bmatrix} d_X \\ d_Y \end{bmatrix}$ is then operated on as follows to produce the beam product
\begin{equation}
    B = \begin{bmatrix} b_X \\ b_Y \end{bmatrix} = \sum_a J^{-1}WD
\end{equation}
where the sum is over the antennas, giving a detected beam, $B$, that is a function of channel number only.

\subsubsection{Efficiency via pre-calculation}
\label{sec:precalc1}
Since, within a second, every sample is multiplied to the same $J^{-1}$ and $W$, the possibility exists for a processing speed by means of pre-calculating the product
\begin{equation}
    F = \begin{bmatrix} f_{XX} & f_{XY} \\ f_{YX} & f_{YY} \end{bmatrix} = J^{-1} W.
\end{equation}
Expressed in terms of the individual components, the calculated beam would then be
\begin{equation}
    b_P = \sum_a \bigg(f_{PX} \, d_X + f_{PY} \, d_Y\bigg),
\end{equation}
where
\begin{equation}
    f_{PQ} = j_{PQ} w_Q.
\end{equation}
Unfortunately, such a pre-calculation was found not to reduce significantly the number of mathematical operations required in the innermost for-loop, and the total time was found to be comprable to the case where the pre-calculation step was not used.
Therefore, this approach was abandoned.

\subsection{Noise floor}
In preparation for calculating the Stokes parameters, a quantity called the \texttt{noise\_floor} is calculated, which is a function of channel only,
\begin{equation}
    N = \begin{bmatrix} n_{XX} & n_{XY} \\ n_{YX} & n_{YY} \end{bmatrix}
      = \sum_a BB^\dagger
\end{equation}
where $\dagger$ denotes the Hermitian transpose.
In particular, note that $n_{XY,c} = n_{YX,c}$.

\subsubsection{Efficiency via pre-calculation}
Similarly to the pre-calculation attempted in Section \ref{sec:precalc1}, pre-calculation of the quantities within the product $BB^\dagger$ was attempted in the effort to speed up the overall computation.
This involved expanding the product $BB^\dagger$ as a linear combination of $d_X$ and $d_Y$ (and their conjugates) and pre-calculating the coefficients.
This turned out to actually increase the number of mathematical operations within the innermost for-loop (by virtue of the linear sum), and thus \emph{increase} the total wall time.
Thus, this approach was also abandoned.

\subsection{Stokes parameters}

Finally, the Stokes parameters $I$, $Q$, $U$, and $V$, are calculated as follows.
\begin{align}
    I &= \frac{1}{w_\text{ant}}\bigg((|b_X|^2 - n_{XX}) + (|b_Y|^2 - n_{YY})\bigg) \\
    Q &= \frac{1}{w_\text{ant}}\bigg((|b_X|^2 - n_{XX}) - (|b_Y|^2 - n_{YY})\bigg) \\
    U &=  2 \text{Re}\bigg[\frac{1}{w_\text{ant}}\bigg(b_X\,\bar{b}_Y - n_{XY}\bigg)\bigg]\\
    V &= -2 \text{Im}\bigg[\frac{1}{w_\text{ant}}\bigg(b_X\,\bar{b}_Y - n_{XY}\bigg)\bigg]
\end{align}
where $w_\text{ant}$ is a weighting factor equal to the number of antennas used in the sums.

\newpage
\section{Inverting the PFB}

It is sometimes desirable to sacrifice spectral information for a higher time resolution.
Unfortunately, this is non-trivial due to the (strictly) non-invertible process applied to the original high time resolution to get the spectral information in the first place, viz. the polyphase filter bank, or PFB.
In principle, however, a decent reconstruction of the input time series can be obtained.
In light of this, it may actually be closer to the mark to call the process `resynthesis' instead of `inversion', but I will continue to call it `inversion' here.

Here is the algorithm as I read it from Stephen's current code:\\[10pt]
\newcommand{\blue}[1]{{\color{blue}#1}}
\newcommand{\red}[1]{{\color{red}#1}}
\newcommand{\arrsize}[1]{{\color{red}[}#1{\color{red}]}}
\newcommand{\vrbl}[1]{{\texttt{\blue{#1}}}}

\subsubsection*{Variables:}
\begin{itemize}
    \item \texttt{int \blue{sample\_rate} = \blue{10000}}
    \item \texttt{int \blue{vf.sample\_rate} = sample\_rate * 128 = \blue{1280000}}
    \item \texttt{int \blue{vf.samples\_per\_frame} = \blue{128}}
    \item \texttt{int \blue{vf.frame\_rate} = vf.sample\_rate / vf.samples\_per\_frame = \blue{10000}}
    \item \texttt{int \blue{vf.nchan} = \blue{2}}
    \item \texttt{int \blue{vf.iscomplex} = \blue{1}}
    \item \texttt{int \blue{vf.sizeof\_beam} = vf.samples\_per\_frame * vf.nchan * (vf.iscomplex+1) = \blue{512}}
    \item \texttt{int \blue{vf.sizeof\_buffer} = vf.frame\_rate * vf.sizeof\_beam = \blue{5120000}}
    \item \texttt{int \blue{ntap\_per\_call} = \blue{2}}
    \item \texttt{int \blue{fcontext.ntaps} = \blue{1536}}
    \item \texttt{int \blue{fcontext.nsamples} = vf.sizeof\_buffer / vf.nchan = \blue{2560000}} (line 1733 of \texttt{make\_beam.c})
    \item \texttt{int \blue{fcontext.nsamples} = ntap\_per\_call * fcontext.ntaps = \blue{3072}? or \blue{65536}?} (line 2250 of \texttt{make\_beam.c})
    \item \texttt{int \blue{upsample\_factor} = \blue{128}}
\end{itemize}

\subsubsection*{Arrays:}
\begin{itemize}
    \item \texttt{complex float \blue{upsample\_working}\arrsize{upsample\_factor*nsamples = \blue{393216}}}
    \item \texttt{complex float \blue{filter\_dft\_in}\arrsize{upsample\_factor*nsamples = \blue{393216}}}
    \item \texttt{complex float \blue{filter\_dft\_out}\arrsize{upsample\_factor*nsamples = \blue{393216}}}
    \item \texttt{complex float \blue{in}\arrsize{nchan\_in = \blue{128}}\arrsize{upsample\_factor*nsamples = \blue{393216}}}
    \item \texttt{complex float \blue{out}\arrsize{nchan\_in = \blue{128}}\arrsize{upsample\_factor*nsamples = \blue{393216}}}
\end{itemize}

\subsubsection*{Pseudocode:}
\begin{enumerate}
    \item Fill \vrbl{upsample\_working} and \vrbl{filter\_dft\_in} with zeros
    \item Populate \vrbl{filter\_dft\_in} with the (real) filter coefficients and Fourier transform them (forward) storing the (complex) result in \vrbl{filter\_dft\_out}.
    \item Populate \vrbl{in} as follows (upsampling step):
        \begin{equation}
            \texttt{in[ch][i]} =
            \begin{cases}
                \texttt{input[i+ch]}, & \text{\texttt{i} is a multiple of 128} \\
                0, & \text{otherwise}
            \end{cases}
        \end{equation}
        This is a merely a rearrangement of the input data from a 1D array:\\[8pt]
        \texttt{[i=0,ch=0], [i=0,ch=1], \dots [i=0,ch=127], [i=1,ch=0], [i=1,ch=1], \dots}\\[8pt]
        To a 2D array:\\[8pt]
        \texttt{ch=0: [i=0], 0, 0, \dots [i=1], 0, 0, \dots [i=2], \dots}\\
        \texttt{ch=1: [i=0], 0, 0, \dots [i=1], 0, 0, \dots [i=2], \dots}\\
        \texttt{ch=2: \dots}\\[8pt]
        where there are 127 zeros between each input sample.
    \item Fourier transform (forward) each row of \vrbl{in}.
    \item Populate \vrbl{upsample\_working} as follows:
        \begin{equation}
            \texttt{upsample\_working[i]}
              = \sum_{\texttt{ch}=0}^{128} \texttt{filter\_dft\_out[i]} \times \texttt{out[ch][i]}
        \end{equation}
    \item Backward FFT \vrbl{upsample\_working}. This is the desired result.
\end{enumerate}

\end{document}
